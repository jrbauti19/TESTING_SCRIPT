/**
 * Vulnerability Tester Module
 *
 * Tests for common web vulnerabilities including XSS, information disclosure,
 * and input validation issues
 *
 * @author Joshua Bautista
 * @contact jrbauti19@gmail.com
 */

const { chromium } = require('playwright');
const https = require('https');
const http = require('http');
const url = require('url');

class VulnerabilityTester {
  /**
   * Initialize vulnerability tester
   * @param {Object} options - Configuration options
   * @param {string} options.targetUrl - Target URL to test
   * @param {number} options.timeout - Request timeout in milliseconds
   * @param {boolean} options.verbose - Enable verbose logging
   */
  constructor(options = {}) {
    this.targetUrl = options.targetUrl || 'https://news.ycombinator.com';
    this.timeout = options.timeout || 30000;
    this.verbose = options.verbose || false;
  }

  /**
   * Test for XSS vulnerabilities
   * @returns {Promise<Object>} Test results
   */
  async testXSSVulnerabilities() {
    const test = {
      name: 'XSS Vulnerability Assessment',
      status: 'UNKNOWN',
      score: 0,
      maxScore: 10,
      details: [],
      issues: [],
    };

    try {
      const browser = await chromium.launch({ headless: true });
      const page = await browser.newPage();

      // Set up XSS detection
      let xssDetected = false;
      page.on('dialog', async (dialog) => {
        if (dialog.message().includes('XSS') || dialog.type() === 'alert') {
          xssDetected = true;
          await dialog.dismiss();
        }
      });

      await page.goto(this.targetUrl);

      // Test for reflected XSS in URL parameters
      await this.testReflectedXSS(page, test);

      // Test for stored XSS (basic)
      await this.testStoredXSS(page, test);

      // Check for XSS protection headers
      await this.testXSSProtectionHeaders(test);

      await browser.close();

      // Determine final status
      test.status = xssDetected
        ? 'FAIL'
        : this.determineStatus(test.score, test.maxScore);
    } catch (error) {
      test.status = 'ERROR';
      test.details.push(`‚ùå Error: ${error.message}`);
    }

    return test;
  }

  /**
   * Test for reflected XSS vulnerabilities
   * @param {Object} page - Playwright page object
   * @param {Object} test - Test result object to update
   */
  async testReflectedXSS(page, test) {
    const testPayloads = [
      '<script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '"><script>alert("XSS")</script>',
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>',
    ];

    let xssDetected = false;

    for (const payload of testPayloads) {
      try {
        const testUrl = `${this.targetUrl}?q=${encodeURIComponent(payload)}`;
        await page.goto(testUrl, { timeout: 5000 });
        await page.waitForTimeout(1000);

        // Check if alert was triggered
        const dialogHandled = await page.evaluate(() => {
          return window.alertTriggered || false;
        });

        if (dialogHandled) {
          test.details.push('‚ùå Potential XSS vulnerability detected');
          test.issues.push('XSS vulnerability requires immediate attention');
          xssDetected = true;
          break;
        }
      } catch (e) {
        // Continue testing other payloads
      }
    }

    if (!xssDetected) {
      test.details.push('‚úÖ No obvious XSS vulnerabilities detected');
      test.score += 8;
    }
  }

  /**
   * Test for stored XSS vulnerabilities (basic)
   * @param {Object} page - Playwright page object
   * @param {Object} test - Test result object to update
   */
  async testStoredXSS(page, test) {
    try {
      // Look for input fields that might be vulnerable
      const inputs = await page.$$('input[type="text"], textarea');

      if (inputs.length > 0) {
        test.details.push(`üìä ${inputs.length} input field(s) detected`);

        // Check if inputs have proper validation
        const validatedInputs = await page.evaluate(() => {
          const inputs = document.querySelectorAll(
            'input[type="text"], textarea',
          );
          let validatedCount = 0;

          inputs.forEach((input) => {
            if (input.pattern || input.maxLength || input.required) {
              validatedCount++;
            }
          });

          return validatedCount;
        });

        if (validatedInputs > 0) {
          test.details.push(
            `‚úÖ ${validatedInputs} input(s) have validation attributes`,
          );
        } else {
          test.details.push('‚ö†Ô∏è  No client-side validation detected');
          test.issues.push('Consider adding input validation attributes');
        }
      }
    } catch (error) {
      test.details.push(`‚ö†Ô∏è  Stored XSS test failed: ${error.message}`);
    }
  }

  /**
   * Test XSS protection headers
   * @param {Object} test - Test result object to update
   */
  async testXSSProtectionHeaders(test) {
    try {
      const response = await this.makeRequest(this.targetUrl);
      const xssProtection = response.headers['x-xss-protection'];

      if (xssProtection && xssProtection.includes('1')) {
        test.details.push('‚úÖ X-XSS-Protection header enabled');
        test.score += 2;
      } else {
        test.details.push('‚ö†Ô∏è  X-XSS-Protection header not optimal');
        test.issues.push('Consider enabling X-XSS-Protection header');
      }
    } catch (error) {
      test.details.push(
        `‚ö†Ô∏è  XSS protection header test failed: ${error.message}`,
      );
    }
  }

  /**
   * Test for information disclosure
   * @returns {Promise<Object>} Test results
   */
  async testInformationDisclosure() {
    const test = {
      name: 'Information Disclosure',
      status: 'UNKNOWN',
      score: 0,
      maxScore: 10,
      details: [],
      issues: [],
    };

    try {
      const response = await this.makeRequest(this.targetUrl);
      const headers = response.headers || {};

      // Check for information disclosure in headers
      await this.testHeaderDisclosure(headers, test);

      // Check for sensitive files
      await this.testSensitiveFiles(test);

      // Determine final status
      test.status = this.determineStatus(test.score, test.maxScore);
    } catch (error) {
      test.status = 'ERROR';
      test.details.push(`‚ùå Error: ${error.message}`);
    }

    return test;
  }

  /**
   * Test for information disclosure in headers
   * @param {Object} headers - Response headers
   * @param {Object} test - Test result object to update
   */
  async testHeaderDisclosure(headers, test) {
    const sensitiveHeaders = [
      'server',
      'x-powered-by',
      'x-aspnet-version',
      'x-aspnetmvc-version',
      'x-runtime',
      'x-version',
    ];

    let disclosureCount = 0;

    sensitiveHeaders.forEach((header) => {
      if (headers[header]) {
        test.details.push(`‚ö†Ô∏è  ${header} header reveals: ${headers[header]}`);
        test.issues.push(`Consider removing or obfuscating ${header} header`);
        disclosureCount++;
      }
    });

    if (disclosureCount === 0) {
      test.details.push('‚úÖ No obvious information disclosure in headers');
      test.score += 5;
    }
  }

  /**
   * Test for accessible sensitive files
   * @param {Object} test - Test result object to update
   */
  async testSensitiveFiles(test) {
    const sensitiveUrls = [
      '/robots.txt',
      '/.git/config',
      '/admin',
      '/config',
      '/.env',
      '/wp-config.php',
      '/phpinfo.php',
      '/.htaccess',
      '/web.config',
    ];

    let accessibleFiles = 0;

    for (const path of sensitiveUrls) {
      try {
        const testUrl = new URL(path, this.targetUrl).href;
        const testResponse = await this.makeRequest(testUrl);

        if (testResponse.statusCode === 200) {
          if (path === '/robots.txt') {
            test.details.push('‚úÖ robots.txt accessible (normal)');
          } else {
            test.details.push(`‚ö†Ô∏è  Sensitive path accessible: ${path}`);
            test.issues.push(`Restrict access to ${path}`);
            accessibleFiles++;
          }
        }
      } catch (e) {
        // Expected for most paths
      }
    }

    if (accessibleFiles === 0) {
      test.details.push('‚úÖ No sensitive files accessible');
      test.score += 5;
    }
  }

  /**
   * Test input validation
   * @returns {Promise<Object>} Test results
   */
  async testInputValidation() {
    const test = {
      name: 'Input Validation',
      status: 'UNKNOWN',
      score: 0,
      maxScore: 5,
      details: [],
      issues: [],
    };

    try {
      const browser = await chromium.launch({ headless: true });
      const page = await browser.newPage();
      await page.goto(this.targetUrl);

      // Find input fields
      const inputs = await page.$$('input, textarea');

      if (inputs.length > 0) {
        test.details.push(`üìä ${inputs.length} input field(s) detected`);

        // Check for basic input validation attributes
        const validationStats = await page.evaluate(() => {
          const inputs = document.querySelectorAll('input, textarea');
          let validatedInputs = 0;
          let emailInputs = 0;
          let requiredInputs = 0;

          inputs.forEach((input) => {
            const type = input.getAttribute('type');
            const required = input.getAttribute('required');
            const pattern = input.getAttribute('pattern');
            const maxlength = input.getAttribute('maxlength');

            if (
              required ||
              pattern ||
              maxlength ||
              ['email', 'url', 'tel'].includes(type)
            ) {
              validatedInputs++;
            }

            if (type === 'email') emailInputs++;
            if (required) requiredInputs++;
          });

          return {
            validatedInputs,
            emailInputs,
            requiredInputs,
            total: inputs.length,
          };
        });

        if (validationStats.validatedInputs > 0) {
          test.details.push(
            `‚úÖ ${validationStats.validatedInputs} input(s) have validation attributes`,
          );
          test.score += 3;
        } else {
          test.details.push('‚ö†Ô∏è  No client-side validation detected');
          test.issues.push('Consider adding input validation attributes');
        }

        if (validationStats.emailInputs > 0) {
          test.details.push(
            `‚úÖ ${validationStats.emailInputs} email input(s) detected`,
          );
        }

        if (validationStats.requiredInputs > 0) {
          test.details.push(
            `‚úÖ ${validationStats.requiredInputs} required input(s) detected`,
          );
        }
      } else {
        test.details.push('‚ÑπÔ∏è  No input fields detected on main page');
        test.score += 3; // No inputs = no input validation issues
      }

      await browser.close();

      // Determine final status
      test.status = this.determineStatus(test.score, test.maxScore);
    } catch (error) {
      test.status = 'ERROR';
      test.details.push(`‚ùå Error: ${error.message}`);
    }

    return test;
  }

  /**
   * Make HTTP/HTTPS request
   * @param {string} targetUrl - URL to request
   * @returns {Promise<Object>} Response object
   */
  makeRequest(targetUrl) {
    return new Promise((resolve, reject) => {
      const parsedUrl = url.parse(targetUrl);
      const client = parsedUrl.protocol === 'https:' ? https : http;

      const options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.path,
        method: 'GET',
        timeout: this.timeout,
        headers: {
          'User-Agent': 'SecurityTester/1.0 (QA Wolf Assessment)',
        },
      };

      const req = client.request(options, (res) => {
        let data = '';
        res.on('data', (chunk) => (data += chunk));
        res.on('end', () => {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            data: data,
          });
        });
      });

      req.on('error', reject);
      req.on('timeout', () => reject(new Error('Request timeout')));
      req.end();
    });
  }

  /**
   * Determine test status based on score
   * @param {number} score - Current score
   * @param {number} maxScore - Maximum possible score
   * @returns {string} Status (PASS, WARN, FAIL)
   */
  determineStatus(score, maxScore) {
    const percentage = (score / maxScore) * 100;

    if (percentage >= 80) return 'PASS';
    if (percentage >= 50) return 'WARN';
    return 'FAIL';
  }
}

module.exports = VulnerabilityTester;
